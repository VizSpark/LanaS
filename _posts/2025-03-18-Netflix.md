---
layout: post
title: The Evolution of Netflix
subtitle: K-Means Clustering
cover-img: /assets/img/NetflixBanner.jpg
thumbnail-img: /assets/img/Netflix.png
share-img: /assets/img/NetflixBanner.jpg
author: Lana Sisson
---

# **The Evolution of Netflix - Clustering** 


<h2 style="color: red;">Executive Summary</h2>
The growth of Netflix, Amazon Prime and other streaming services is of great interest as a movie fan and the evolution of how we now ingest our media. This project aims to identify the trends from Netflix Data sourced from Kaggle, to observe how content released by year has changed in volume and evolved over time, including differences in genre popularity and regional trends, for example original content vs certain genre types, further analyzing any additional insights that are identifiable using clustering algorithms

The output of the clustering models was validated against Silhouette Score, Calinski-Harabasz Index and Davies-Bouldin Index. The results show the change in density of increase in Content length by release year, which highlights changes movie into the pandemic with TV Shows season length increase over recent years, with clear gap analysis showing strategic opportunities by Country and Genre

The learning from this project offered great insight into new work-based projects, especially looking at the growth and change of key brands within the market and how their sales have changed over time, from regional level date to specifics on customer type and brand purchased. This will impact on the company by allowing patterns and trends to be identified to support marketing and the acquisition logistics for our Trading and Logistics teams.


<h2 style="color: red;">Data Infrastructure and Tooling</h2>

The tool used will be Python, other considerations were Excel, Power BI, MicroStrategy. Although Power BI and MicroStrategy offer fantastic Visuals and interactivity, what they lack is the ability to Fine Tune parameters that are more achievable through Python and clustering Algorithms, Power BI allows for customization, but it is not intuitive to use and cumbersome to integrate without extensive knowledge, Parameter tuning is more straightforward within Python for example with libraries like scikit-learn with extensive options. To allow this flexibility and variety the decision was to use python.

K-Means Clustering will be used in this project versus Hierarchical. K-Means is efficient and scalable algorithm for large datasets, The clusters formed as part of K-Means are simple and easily interpreted, by each cluster being formed around a centroid, finally K-Means offers flexibility allowing the number of clusters to be changed to explore more granular detail.

Other considerations were hierarchical clustering and DBSCAN, Hierarchical was not chosen as it can be computationally heavy, especially with using large datasets, within intention of future scalability, finally based on it creating a dendrogram (tree like diagram) – it is not easy to adjust the number of clusters and often too complex to interpret. DBSCAN requires very careful tuning of parameters which can make the results significantly varied also time consuming to align, finally not performing well if the clusters are not arbitrarily shaped and like hierarchical being heavy computationally, Due to K-Means Efficient, scalable, flexible and easily interpretable this is the algorithm that will form key foundation of the project.



When looking at Netflix's evolving strategy it sits on multiple key pillars.

1. A reduction to fewer, yet higher quality productions maximize subscriber engagement. (AInvest. 2025)  
2. Netflix seeks to generate earned media value through conversation-starting, "buzzworthy" content like Jake Paul vs Mike Tyson, NFL, WWE. (Oakes, O. 2025)
3. Netflix is pursuing a selective approach to live programming, only investing where it offers unique value for diversification and subscriber growth. (AInvest. 2025) and (Oakes, O. 2025).
4. Further integration AI to enhance personalization, building better recommendation, supporting customer satisfaction, and stronger retention rates. (Works, A. 2024) and (Livemint. 2025).

The requirement for strategic content, Increased media coverage, targeted content, powered by AI personalising the platform  – will be vital for navigating the ever-changing streaming platform landscape.


<h2 style="color: red;">Data Preparation (Pre-Processing) </h2> 


<h3><u>Step 1. Import Necessary Libraries </u></h3>

![Alt text describing image output_143_0]({{ '/assets/img/Step One to Three.png' | relative_url }})

![Alt text describing image output_143_0]({{ '/assets/img/step one.png' | relative_url }})

```python
import pandas as pd #pandas is essential for data manipulation
import numpy as np #numpy is essential for mathmatical functions

from sklearn.preprocessing import StandardScaler,LabelEncoder,OneHotEncoder  #for scaling numerical features.
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.cluster import KMeans #for the K-Means algorithm.
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import silhouette_score,calinski_harabasz_score, davies_bouldin_score #Model validation
from sklearn.metrics import silhouette_samples
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.decomposition import PCA
from scipy.sparse import hstack


import seaborn as sns #for enhanced visualizations.
import matplotlib.cm as cm # Import the matplotlib.cm module
import matplotlib.patches as mpatches # Import for custom legend handles
import matplotlib.pyplot as plt #for basic plotting.
import matplotlib.lines as mlines # Import for custom legend handles
import matplotlib.ticker as mticker # Import for percentage formatting

```

<h3><u>Step 2. Load the data</u></h3>


```python
nf = pd.read_csv('Netflix.csv')
```

<h3><u>Step 3. Inspect the data</u></h3>


```python
nf.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>release_year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>8807.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>2014.180198</td>
    </tr>
    <tr>
      <th>std</th>
      <td>8.819312</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1925.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>2013.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>2017.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2019.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>2021.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
nf.head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>show_id</th>
      <th>type</th>
      <th>title</th>
      <th>director</th>
      <th>cast</th>
      <th>country</th>
      <th>date_added</th>
      <th>release_year</th>
      <th>rating</th>
      <th>duration</th>
      <th>listed_in</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>s1</td>
      <td>Movie</td>
      <td>Dick Johnson Is Dead</td>
      <td>Kirsten Johnson</td>
      <td>NaN</td>
      <td>United States</td>
      <td>September 25, 2021</td>
      <td>2020</td>
      <td>PG-13</td>
      <td>90 min</td>
      <td>Documentaries</td>
      <td>As her father nears the end of his life, filmm...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>s2</td>
      <td>TV Show</td>
      <td>Blood &amp; Water</td>
      <td>NaN</td>
      <td>Ama Qamata, Khosi Ngema, Gail Mabalane, Thaban...</td>
      <td>South Africa</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>International TV Shows, TV Dramas, TV Mysteries</td>
      <td>After crossing paths at a party, a Cape Town t...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>s3</td>
      <td>TV Show</td>
      <td>Ganglands</td>
      <td>Julien Leclercq</td>
      <td>Sami Bouajila, Tracy Gotoas, Samuel Jouy, Nabi...</td>
      <td>NaN</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>Crime TV Shows, International TV Shows, TV Act...</td>
      <td>To protect his family from a powerful drug lor...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>s4</td>
      <td>TV Show</td>
      <td>Jailbirds New Orleans</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>Docuseries, Reality TV</td>
      <td>Feuds, flirtations and toilet talk go down amo...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>s5</td>
      <td>TV Show</td>
      <td>Kota Factory</td>
      <td>NaN</td>
      <td>Mayur More, Jitendra Kumar, Ranjan Raj, Alam K...</td>
      <td>India</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>International TV Shows, Romantic TV Shows, TV ...</td>
      <td>In a city of coaching centers known to train I...</td>
    </tr>
  </tbody>
</table>
</div>




```python
nf.shape
```




    (8807, 12)




```python
nf.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 8807 entries, 0 to 8806
    Data columns (total 12 columns):
     #   Column        Non-Null Count  Dtype 
    ---  ------        --------------  ----- 
     0   show_id       8807 non-null   object
     1   type          8807 non-null   object
     2   title         8807 non-null   object
     3   director      6173 non-null   object
     4   cast          7982 non-null   object
     5   country       7976 non-null   object
     6   date_added    8797 non-null   object
     7   release_year  8807 non-null   int64 
     8   rating        8803 non-null   object
     9   duration      8804 non-null   object
     10  listed_in     8807 non-null   object
     11  description   8807 non-null   object
    dtypes: int64(1), object(11)
    memory usage: 825.8+ KB
    

<h3><u>Step 4. Manage and Remove Missing values</u></h3>

It was identified 7 columns had missing values each column was reviewed independently to access impact on wider data frame

- **date_added** equated to 0.1135% of total data set – missing values (appendix 1.1)
- **rating** equated to 0.04542% of total data set – missing values (appendix 1.2)
- **duration** in this instance had been added into the incorrect rating column, causing a misalignment into listed_in column equated to 0.03406% total dataset (appendix 1.3)

These rows were dropped from the dataset due to low impact



```python
nf.isnull().sum()
```




    show_id            0
    type               0
    title              0
    director        2634
    cast             825
    country          831
    date_added        10
    release_year       0
    rating             4
    duration           3
    listed_in          0
    description        0
    dtype: int64




```python
nf[nf['date_added'].isnull()]
# as there are 8807 rows, 0.1135% of the total dataset - these null values will be dropped due to low %
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>show_id</th>
      <th>type</th>
      <th>title</th>
      <th>director</th>
      <th>cast</th>
      <th>country</th>
      <th>date_added</th>
      <th>release_year</th>
      <th>rating</th>
      <th>duration</th>
      <th>listed_in</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6066</th>
      <td>s6067</td>
      <td>TV Show</td>
      <td>A Young Doctor's Notebook and Other Stories</td>
      <td>NaN</td>
      <td>Daniel Radcliffe, Jon Hamm, Adam Godley, Chris...</td>
      <td>United Kingdom</td>
      <td>NaN</td>
      <td>2013</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>British TV Shows, TV Comedies, TV Dramas</td>
      <td>Set during the Russian Revolution, this comic ...</td>
    </tr>
    <tr>
      <th>6174</th>
      <td>s6175</td>
      <td>TV Show</td>
      <td>Anthony Bourdain: Parts Unknown</td>
      <td>NaN</td>
      <td>Anthony Bourdain</td>
      <td>United States</td>
      <td>NaN</td>
      <td>2018</td>
      <td>TV-PG</td>
      <td>5 Seasons</td>
      <td>Docuseries</td>
      <td>This CNN original series has chef Anthony Bour...</td>
    </tr>
    <tr>
      <th>6795</th>
      <td>s6796</td>
      <td>TV Show</td>
      <td>Frasier</td>
      <td>NaN</td>
      <td>Kelsey Grammer, Jane Leeves, David Hyde Pierce...</td>
      <td>United States</td>
      <td>NaN</td>
      <td>2003</td>
      <td>TV-PG</td>
      <td>11 Seasons</td>
      <td>Classic &amp; Cult TV, TV Comedies</td>
      <td>Frasier Crane is a snooty but lovable Seattle ...</td>
    </tr>
    <tr>
      <th>6806</th>
      <td>s6807</td>
      <td>TV Show</td>
      <td>Friends</td>
      <td>NaN</td>
      <td>Jennifer Aniston, Courteney Cox, Lisa Kudrow, ...</td>
      <td>United States</td>
      <td>NaN</td>
      <td>2003</td>
      <td>TV-14</td>
      <td>10 Seasons</td>
      <td>Classic &amp; Cult TV, TV Comedies</td>
      <td>This hit sitcom follows the merry misadventure...</td>
    </tr>
    <tr>
      <th>6901</th>
      <td>s6902</td>
      <td>TV Show</td>
      <td>Gunslinger Girl</td>
      <td>NaN</td>
      <td>Yuuka Nanri, Kanako Mitsuhashi, Eri Sendai, Am...</td>
      <td>Japan</td>
      <td>NaN</td>
      <td>2008</td>
      <td>TV-14</td>
      <td>2 Seasons</td>
      <td>Anime Series, Crime TV Shows</td>
      <td>On the surface, the Social Welfare Agency appe...</td>
    </tr>
    <tr>
      <th>7196</th>
      <td>s7197</td>
      <td>TV Show</td>
      <td>Kikoriki</td>
      <td>NaN</td>
      <td>Igor Dmitriev</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2010</td>
      <td>TV-Y</td>
      <td>2 Seasons</td>
      <td>Kids' TV</td>
      <td>A wacky rabbit and his gang of animal pals hav...</td>
    </tr>
    <tr>
      <th>7254</th>
      <td>s7255</td>
      <td>TV Show</td>
      <td>La Familia P. Luche</td>
      <td>NaN</td>
      <td>Eugenio Derbez, Consuelo Duval, Luis Manuel Áv...</td>
      <td>United States</td>
      <td>NaN</td>
      <td>2012</td>
      <td>TV-14</td>
      <td>3 Seasons</td>
      <td>International TV Shows, Spanish-Language TV Sh...</td>
      <td>This irreverent sitcom featues Ludovico, Feder...</td>
    </tr>
    <tr>
      <th>7406</th>
      <td>s7407</td>
      <td>TV Show</td>
      <td>Maron</td>
      <td>NaN</td>
      <td>Marc Maron, Judd Hirsch, Josh Brener, Nora Zeh...</td>
      <td>United States</td>
      <td>NaN</td>
      <td>2016</td>
      <td>TV-MA</td>
      <td>4 Seasons</td>
      <td>TV Comedies</td>
      <td>Marc Maron stars as Marc Maron, who interviews...</td>
    </tr>
    <tr>
      <th>7847</th>
      <td>s7848</td>
      <td>TV Show</td>
      <td>Red vs. Blue</td>
      <td>NaN</td>
      <td>Burnie Burns, Jason Saldaña, Gustavo Sorola, G...</td>
      <td>United States</td>
      <td>NaN</td>
      <td>2015</td>
      <td>NR</td>
      <td>13 Seasons</td>
      <td>TV Action &amp; Adventure, TV Comedies, TV Sci-Fi ...</td>
      <td>This parody of first-person shooter games, mil...</td>
    </tr>
    <tr>
      <th>8182</th>
      <td>s8183</td>
      <td>TV Show</td>
      <td>The Adventures of Figaro Pho</td>
      <td>NaN</td>
      <td>Luke Jurevicius, Craig Behenna, Charlotte Haml...</td>
      <td>Australia</td>
      <td>NaN</td>
      <td>2015</td>
      <td>TV-Y7</td>
      <td>2 Seasons</td>
      <td>Kids' TV, TV Comedies</td>
      <td>Imagine your worst fears, then multiply them: ...</td>
    </tr>
  </tbody>
</table>
</div>




```python
nf[nf['rating'].isnull()]
# as there are 8807 rows, 0.04542% of the total dataset - these null values will be dropped due to low % - no great impact to full dataset
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>show_id</th>
      <th>type</th>
      <th>title</th>
      <th>director</th>
      <th>cast</th>
      <th>country</th>
      <th>date_added</th>
      <th>release_year</th>
      <th>rating</th>
      <th>duration</th>
      <th>listed_in</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5989</th>
      <td>s5990</td>
      <td>Movie</td>
      <td>13TH: A Conversation with Oprah Winfrey &amp; Ava ...</td>
      <td>NaN</td>
      <td>Oprah Winfrey, Ava DuVernay</td>
      <td>NaN</td>
      <td>January 26, 2017</td>
      <td>2017</td>
      <td>NaN</td>
      <td>37 min</td>
      <td>Movies</td>
      <td>Oprah Winfrey sits down with director Ava DuVe...</td>
    </tr>
    <tr>
      <th>6827</th>
      <td>s6828</td>
      <td>TV Show</td>
      <td>Gargantia on the Verdurous Planet</td>
      <td>NaN</td>
      <td>Kaito Ishikawa, Hisako Kanemoto, Ai Kayano, Ka...</td>
      <td>Japan</td>
      <td>December 1, 2016</td>
      <td>2013</td>
      <td>NaN</td>
      <td>1 Season</td>
      <td>Anime Series, International TV Shows</td>
      <td>After falling through a wormhole, a space-dwel...</td>
    </tr>
    <tr>
      <th>7312</th>
      <td>s7313</td>
      <td>TV Show</td>
      <td>Little Lunch</td>
      <td>NaN</td>
      <td>Flynn Curry, Olivia Deeble, Madison Lu, Oisín ...</td>
      <td>Australia</td>
      <td>February 1, 2018</td>
      <td>2015</td>
      <td>NaN</td>
      <td>1 Season</td>
      <td>Kids' TV, TV Comedies</td>
      <td>Adopting a child's perspective, this show take...</td>
    </tr>
    <tr>
      <th>7537</th>
      <td>s7538</td>
      <td>Movie</td>
      <td>My Honor Was Loyalty</td>
      <td>Alessandro Pepe</td>
      <td>Leone Frisa, Paolo Vaccarino, Francesco Miglio...</td>
      <td>Italy</td>
      <td>March 1, 2017</td>
      <td>2015</td>
      <td>NaN</td>
      <td>115 min</td>
      <td>Dramas</td>
      <td>Amid the chaos and horror of World War II, a c...</td>
    </tr>
  </tbody>
</table>
</div>




```python
nf[nf['duration'].isnull()]
# duration in this instance has been addded into the WRONG rating column, these rows will be dropped as 0.03406% of dataset - no great impact to full dataset
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>show_id</th>
      <th>type</th>
      <th>title</th>
      <th>director</th>
      <th>cast</th>
      <th>country</th>
      <th>date_added</th>
      <th>release_year</th>
      <th>rating</th>
      <th>duration</th>
      <th>listed_in</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5541</th>
      <td>s5542</td>
      <td>Movie</td>
      <td>Louis C.K. 2017</td>
      <td>Louis C.K.</td>
      <td>Louis C.K.</td>
      <td>United States</td>
      <td>April 4, 2017</td>
      <td>2017</td>
      <td>74 min</td>
      <td>NaN</td>
      <td>Movies</td>
      <td>Louis C.K. muses on religion, eternal love, gi...</td>
    </tr>
    <tr>
      <th>5794</th>
      <td>s5795</td>
      <td>Movie</td>
      <td>Louis C.K.: Hilarious</td>
      <td>Louis C.K.</td>
      <td>Louis C.K.</td>
      <td>United States</td>
      <td>September 16, 2016</td>
      <td>2010</td>
      <td>84 min</td>
      <td>NaN</td>
      <td>Movies</td>
      <td>Emmy-winning comedy writer Louis C.K. brings h...</td>
    </tr>
    <tr>
      <th>5813</th>
      <td>s5814</td>
      <td>Movie</td>
      <td>Louis C.K.: Live at the Comedy Store</td>
      <td>Louis C.K.</td>
      <td>Louis C.K.</td>
      <td>United States</td>
      <td>August 15, 2016</td>
      <td>2015</td>
      <td>66 min</td>
      <td>NaN</td>
      <td>Movies</td>
      <td>The comic puts his trademark hilarious/thought...</td>
    </tr>
  </tbody>
</table>
</div>




```python
# Drop rows with null values in 'duration', 'rating', 'date_added' columns
columns_to_drop_null = ['duration', 'rating', 'date_added']
nf.dropna(subset=columns_to_drop_null, inplace=True)
```


```python
nf.isnull().sum()
```




    show_id            0
    type               0
    title              0
    director        2621
    cast             825
    country          829
    date_added         0
    release_year       0
    rating             0
    duration           0
    listed_in          0
    description        0
    dtype: int64




```python
#For Director, cast and Country - any Nulls will be replaced with unknown
nf[['director','cast','country']] = nf[['director','cast','country']].fillna('Unknown')
```


```python
#Check to make sure all nulls have been removed
nf.isnull().sum()
```




    show_id         0
    type            0
    title           0
    director        0
    cast            0
    country         0
    date_added      0
    release_year    0
    rating          0
    duration        0
    listed_in       0
    description     0
    dtype: int64



<h3><u>Step 5.	Standardize Columns names</u></h3>


```python
nf = nf.rename(columns={
    'show_id': 'Show ID',
    'type': 'Type',
    'title': 'Title',
    'director': 'Director',
    'cast': 'Cast',
    'country': 'Country',
    'date_added': 'Date Added',
    'release_year': 'Release Year',
    'rating': 'Rating',
    'duration': 'Duration',
    'listed_in': 'Listed In',
    'description': 'Description'
})
```

<h3><u>Step 6. Standardize Category names</u></h3>


```python
nf['Rating'].unique()
```




    array(['PG-13', 'TV-MA', 'PG', 'TV-14', 'TV-PG', 'TV-Y', 'TV-Y7', 'R',
           'TV-G', 'G', 'NC-17', 'NR', 'TV-Y7-FV', 'UR'], dtype=object)




```python
# Changing the values in the rating column
rating_map = {'TV-MA':'18+ yrs old',
              'R':'18+ yrs old',
              'PG-13':'13-15yrs Old',
              'TV-14':'13-15yrs Old',
              'TV-PG':'PG',
              'NR':'18+ yrs old',
              'TV-G':'Kids',
              'TV-Y':'Kids',
              'TV-Y7':'13-17yrs Old',
              'PG':'PG',
              'G':'Kids',
              'NC-17':'15-17yrs Old',
              'TV-Y7-FV':'15-17yrs Old',
              'UR':'18+ yrs old'}
```


```python
nf['New Rating'] = nf['Rating'].map(rating_map) # Maps new aged rating buckets to a new Column named New Rating
nf.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Show ID</th>
      <th>Type</th>
      <th>Title</th>
      <th>Director</th>
      <th>Cast</th>
      <th>Country</th>
      <th>Date Added</th>
      <th>Release Year</th>
      <th>Rating</th>
      <th>Duration</th>
      <th>Listed In</th>
      <th>Description</th>
      <th>New Rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>s1</td>
      <td>Movie</td>
      <td>Dick Johnson Is Dead</td>
      <td>Kirsten Johnson</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>September 25, 2021</td>
      <td>2020</td>
      <td>PG-13</td>
      <td>90 min</td>
      <td>Documentaries</td>
      <td>As her father nears the end of his life, filmm...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>1</th>
      <td>s2</td>
      <td>TV Show</td>
      <td>Blood &amp; Water</td>
      <td>Unknown</td>
      <td>Ama Qamata, Khosi Ngema, Gail Mabalane, Thaban...</td>
      <td>South Africa</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>International TV Shows, TV Dramas, TV Mysteries</td>
      <td>After crossing paths at a party, a Cape Town t...</td>
      <td>18+ yrs old</td>
    </tr>
    <tr>
      <th>2</th>
      <td>s3</td>
      <td>TV Show</td>
      <td>Ganglands</td>
      <td>Julien Leclercq</td>
      <td>Sami Bouajila, Tracy Gotoas, Samuel Jouy, Nabi...</td>
      <td>Unknown</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>Crime TV Shows, International TV Shows, TV Act...</td>
      <td>To protect his family from a powerful drug lor...</td>
      <td>18+ yrs old</td>
    </tr>
    <tr>
      <th>3</th>
      <td>s4</td>
      <td>TV Show</td>
      <td>Jailbirds New Orleans</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>Docuseries, Reality TV</td>
      <td>Feuds, flirtations and toilet talk go down amo...</td>
      <td>18+ yrs old</td>
    </tr>
    <tr>
      <th>4</th>
      <td>s5</td>
      <td>TV Show</td>
      <td>Kota Factory</td>
      <td>Unknown</td>
      <td>Mayur More, Jitendra Kumar, Ranjan Raj, Alam K...</td>
      <td>India</td>
      <td>September 24, 2021</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>International TV Shows, Romantic TV Shows, TV ...</td>
      <td>In a city of coaching centers known to train I...</td>
      <td>18+ yrs old</td>
    </tr>
  </tbody>
</table>
</div>



<h3><u>Step 7. Convert data types</u></h3>


```python
nf.info()
```

    <class 'pandas.core.frame.DataFrame'>
    Index: 8790 entries, 0 to 8806
    Data columns (total 13 columns):
     #   Column        Non-Null Count  Dtype 
    ---  ------        --------------  ----- 
     0   Show ID       8790 non-null   object
     1   Type          8790 non-null   object
     2   Title         8790 non-null   object
     3   Director      8790 non-null   object
     4   Cast          8790 non-null   object
     5   Country       8790 non-null   object
     6   Date Added    8790 non-null   object
     7   Release Year  8790 non-null   int64 
     8   Rating        8790 non-null   object
     9   Duration      8790 non-null   object
     10  Listed In     8790 non-null   object
     11  Description   8790 non-null   object
     12  New Rating    8790 non-null   object
    dtypes: int64(1), object(12)
    memory usage: 961.4+ KB
    


```python
nf['Date Added'] = pd.to_datetime(nf['Date Added'], errors='coerce') # Convert 'Date Added' column from object to datetime
```


```python
if 'Date Added' in nf.columns:
    nf['Date Added'] = pd.to_datetime(nf['Date Added'], format='%B %d, %Y', errors='coerce')
```


```python
nf.info() # Confirmed type chenge
```

    <class 'pandas.core.frame.DataFrame'>
    Index: 8790 entries, 0 to 8806
    Data columns (total 13 columns):
     #   Column        Non-Null Count  Dtype         
    ---  ------        --------------  -----         
     0   Show ID       8790 non-null   object        
     1   Type          8790 non-null   object        
     2   Title         8790 non-null   object        
     3   Director      8790 non-null   object        
     4   Cast          8790 non-null   object        
     5   Country       8790 non-null   object        
     6   Date Added    8702 non-null   datetime64[ns]
     7   Release Year  8790 non-null   int64         
     8   Rating        8790 non-null   object        
     9   Duration      8790 non-null   object        
     10  Listed In     8790 non-null   object        
     11  Description   8790 non-null   object        
     12  New Rating    8790 non-null   object        
    dtypes: datetime64[ns](1), int64(1), object(11)
    memory usage: 961.4+ KB
    

<h3><u>Step 8. Handle Outliers</u></h3>

#### Review outliers by Release Year


```python
plt.figure(figsize=(10, 6))
sns.boxplot(x=nf['Release Year'])
plt.title('Boxplot for Release Year')
plt.xlabel('Release Year')
plt.show()
```


    
![png](output_37_0.png)
    



```python
# Look at the amount of shows at the edge of plot
filtered_data = nf[(nf['Release Year'] >= 1925) & (nf['Release Year'] <= 1960)]
release_year_counts = filtered_data['Release Year'].value_counts().sort_index()
release_year_counts
```




    Release Year
    1925    1
    1942    2
    1943    3
    1944    3
    1945    4
    1946    2
    1947    1
    1954    2
    1955    3
    1956    2
    1958    3
    1959    1
    1960    4
    Name: count, dtype: int64




```python
# Filter the data to show rows with release year of 1925
filtered_data_1925 = nf[nf['Release Year'] == 1925]
filtered_data_1925
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Show ID</th>
      <th>Type</th>
      <th>Title</th>
      <th>Director</th>
      <th>Cast</th>
      <th>Country</th>
      <th>Date Added</th>
      <th>Release Year</th>
      <th>Rating</th>
      <th>Duration</th>
      <th>Listed In</th>
      <th>Description</th>
      <th>New Rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4250</th>
      <td>s4251</td>
      <td>TV Show</td>
      <td>Pioneers: First Women Filmmakers*</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>2018-12-30</td>
      <td>1925</td>
      <td>TV-14</td>
      <td>1 Season</td>
      <td>TV Shows</td>
      <td>This collection restores films from women who ...</td>
      <td>13-15yrs Old</td>
    </tr>
  </tbody>
</table>
</div>




```python
#Look at data specifically between 1940- 1949
filtered_data_1940to1949 = nf[(nf['Release Year'] >= 1940) & (nf['Release Year'] <= 1949)].sort_values(by='Release Year')
filtered_data_1940to1949
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Show ID</th>
      <th>Type</th>
      <th>Title</th>
      <th>Director</th>
      <th>Cast</th>
      <th>Country</th>
      <th>Date Added</th>
      <th>Release Year</th>
      <th>Rating</th>
      <th>Duration</th>
      <th>Listed In</th>
      <th>Description</th>
      <th>New Rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>8205</th>
      <td>s8206</td>
      <td>Movie</td>
      <td>The Battle of Midway</td>
      <td>John Ford</td>
      <td>Henry Fonda, Jane Darwell</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1942</td>
      <td>TV-14</td>
      <td>18 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>Director John Ford captures combat footage of ...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>7790</th>
      <td>s7791</td>
      <td>Movie</td>
      <td>Prelude to War</td>
      <td>Frank Capra</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1942</td>
      <td>TV-14</td>
      <td>52 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>Frank Capra's documentary chronicles the rise ...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>8763</th>
      <td>s8764</td>
      <td>Movie</td>
      <td>WWII: Report from the Aleutians</td>
      <td>John Huston</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1943</td>
      <td>TV-PG</td>
      <td>45 min</td>
      <td>Documentaries</td>
      <td>Filmmaker John Huston narrates this Oscar-nomi...</td>
      <td>PG</td>
    </tr>
    <tr>
      <th>8739</th>
      <td>s8740</td>
      <td>Movie</td>
      <td>Why We Fight: The Battle of Russia</td>
      <td>Frank Capra, Anatole Litvak</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1943</td>
      <td>TV-PG</td>
      <td>82 min</td>
      <td>Documentaries</td>
      <td>This installment of Frank Capra's acclaimed do...</td>
      <td>PG</td>
    </tr>
    <tr>
      <th>8660</th>
      <td>s8661</td>
      <td>Movie</td>
      <td>Undercover: How to Operate Behind Enemy Lines</td>
      <td>John Ford</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1943</td>
      <td>TV-PG</td>
      <td>61 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>This World War II-era training film dramatizes...</td>
      <td>PG</td>
    </tr>
    <tr>
      <th>8419</th>
      <td>s8420</td>
      <td>Movie</td>
      <td>The Memphis Belle: A Story of a\nFlying Fortress</td>
      <td>William Wyler</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1944</td>
      <td>TV-PG</td>
      <td>40 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>This documentary centers on the crew of the B-...</td>
      <td>PG</td>
    </tr>
    <tr>
      <th>8640</th>
      <td>s8641</td>
      <td>Movie</td>
      <td>Tunisian Victory</td>
      <td>Frank Capra, John Huston, Hugh Stewart, Roy Bo...</td>
      <td>Burgess Meredith</td>
      <td>United States, United Kingdom</td>
      <td>2017-03-31</td>
      <td>1944</td>
      <td>TV-14</td>
      <td>76 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>British and American troops join forces to lib...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>8436</th>
      <td>s8437</td>
      <td>Movie</td>
      <td>The Negro Soldier</td>
      <td>Stuart Heisler</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1944</td>
      <td>TV-14</td>
      <td>40 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>This documentary urged African Americans to en...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>7219</th>
      <td>s7220</td>
      <td>Movie</td>
      <td>Know Your Enemy - Japan</td>
      <td>Frank Capra, Joris Ivens</td>
      <td>Walter Huston, Dana Andrews</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1945</td>
      <td>TV-14</td>
      <td>63 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>Though culturally insensitive by modern standa...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>1331</th>
      <td>s1332</td>
      <td>TV Show</td>
      <td>Five Came Back: The Reference Films</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2021-02-09</td>
      <td>1945</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>TV Shows</td>
      <td>This collection includes 12 World War II-era p...</td>
      <td>18+ yrs old</td>
    </tr>
    <tr>
      <th>7575</th>
      <td>s7576</td>
      <td>Movie</td>
      <td>Nazi Concentration Camps</td>
      <td>George Stevens</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1945</td>
      <td>TV-MA</td>
      <td>59 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>Shocking footage shows Nazi concentration camp...</td>
      <td>18+ yrs old</td>
    </tr>
    <tr>
      <th>7930</th>
      <td>s7931</td>
      <td>Movie</td>
      <td>San Pietro</td>
      <td>John Huston</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1945</td>
      <td>TV-14</td>
      <td>32 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>After the Allies invade Italy, the Liri Valley...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>7743</th>
      <td>s7744</td>
      <td>TV Show</td>
      <td>Pioneers of African-American Cinema</td>
      <td>Oscar Micheaux, Spencer Williams, Richard E. N...</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2017-02-01</td>
      <td>1946</td>
      <td>TV-14</td>
      <td>1 Season</td>
      <td>TV Shows</td>
      <td>This newly preserved collection features more ...</td>
      <td>13-15yrs Old</td>
    </tr>
    <tr>
      <th>7294</th>
      <td>s7295</td>
      <td>Movie</td>
      <td>Let There Be Light</td>
      <td>John Huston</td>
      <td>Walter Huston</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1946</td>
      <td>TV-PG</td>
      <td>58 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>Some returning combat veterans suffer scars th...</td>
      <td>PG</td>
    </tr>
    <tr>
      <th>8587</th>
      <td>s8588</td>
      <td>Movie</td>
      <td>Thunderbolt</td>
      <td>William Wyler, John Sturges</td>
      <td>James Stewart, Lloyd Bridges</td>
      <td>United States</td>
      <td>2017-03-31</td>
      <td>1947</td>
      <td>TV-PG</td>
      <td>42 min</td>
      <td>Classic Movies, Documentaries</td>
      <td>A P-47 Thunderbolt squadron is shown in prepar...</td>
      <td>PG</td>
    </tr>
  </tbody>
</table>
</div>



#### Review outliers by Date Added


```python
plt.figure(figsize=(10, 6))
sns.boxplot(x=nf['Date Added'])
plt.title('Boxplot for Date Added')
plt.xlabel('Date Added')
plt.show()
```


    
![png](output_42_0.png)
    



```python
oldest_release_years = nf['Release Year'].nsmallest(10)
print("Oldest 10 Release Years:")
print(oldest_release_years)
```

    Oldest 10 Release Years:
    4250    1925
    7790    1942
    8205    1942
    8660    1943
    8739    1943
    8763    1943
    8419    1944
    8436    1944
    8640    1944
    1331    1945
    Name: Release Year, dtype: int64
    


```python
nf['Decade'] = (nf['Release Year'] // 10) * 10
```


```python
oldest_Date_added = nf['Date Added'].nsmallest(10)
print("Oldest 10 Release Years:")
print(oldest_Date_added)
```

    Oldest 10 Release Years:
    5957   2008-01-01
    6611   2008-02-04
    5956   2009-05-05
    5955   2009-11-18
    7370   2010-11-01
    5954   2011-05-17
    5953   2011-09-27
    5942   2011-10-01
    5943   2011-10-01
    5944   2011-10-01
    Name: Date Added, dtype: datetime64[ns]
    


```python
nf['Decade'] = (nf['Release Year'] // 10) * 10
```


```python
nf.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Show ID</th>
      <th>Type</th>
      <th>Title</th>
      <th>Director</th>
      <th>Cast</th>
      <th>Country</th>
      <th>Date Added</th>
      <th>Release Year</th>
      <th>Rating</th>
      <th>Duration</th>
      <th>Listed In</th>
      <th>Description</th>
      <th>New Rating</th>
      <th>Decade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>s1</td>
      <td>Movie</td>
      <td>Dick Johnson Is Dead</td>
      <td>Kirsten Johnson</td>
      <td>Unknown</td>
      <td>United States</td>
      <td>2021-09-25</td>
      <td>2020</td>
      <td>PG-13</td>
      <td>90 min</td>
      <td>Documentaries</td>
      <td>As her father nears the end of his life, filmm...</td>
      <td>13-15yrs Old</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>1</th>
      <td>s2</td>
      <td>TV Show</td>
      <td>Blood &amp; Water</td>
      <td>Unknown</td>
      <td>Ama Qamata, Khosi Ngema, Gail Mabalane, Thaban...</td>
      <td>South Africa</td>
      <td>2021-09-24</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>International TV Shows, TV Dramas, TV Mysteries</td>
      <td>After crossing paths at a party, a Cape Town t...</td>
      <td>18+ yrs old</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>2</th>
      <td>s3</td>
      <td>TV Show</td>
      <td>Ganglands</td>
      <td>Julien Leclercq</td>
      <td>Sami Bouajila, Tracy Gotoas, Samuel Jouy, Nabi...</td>
      <td>Unknown</td>
      <td>2021-09-24</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>Crime TV Shows, International TV Shows, TV Act...</td>
      <td>To protect his family from a powerful drug lor...</td>
      <td>18+ yrs old</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>3</th>
      <td>s4</td>
      <td>TV Show</td>
      <td>Jailbirds New Orleans</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>Unknown</td>
      <td>2021-09-24</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>1 Season</td>
      <td>Docuseries, Reality TV</td>
      <td>Feuds, flirtations and toilet talk go down amo...</td>
      <td>18+ yrs old</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>4</th>
      <td>s5</td>
      <td>TV Show</td>
      <td>Kota Factory</td>
      <td>Unknown</td>
      <td>Mayur More, Jitendra Kumar, Ranjan Raj, Alam K...</td>
      <td>India</td>
      <td>2021-09-24</td>
      <td>2021</td>
      <td>TV-MA</td>
      <td>2 Seasons</td>
      <td>International TV Shows, Romantic TV Shows, TV ...</td>
      <td>In a city of coaching centers known to train I...</td>
      <td>18+ yrs old</td>
      <td>2020</td>
    </tr>
  </tbody>
</table>
</div>



No outliers are removed, as the release year of a movie is still the release year, and all is valuable, creationof a decade column to help mitigate any potential noise

<h3><u>Step 9. Remove Duplicates</u></h3>


```python
nf.duplicated().sum
# No Duplicated Rows
```




    <bound method Series.sum of 0       False
    1       False
    2       False
    3       False
    4       False
            ...  
    8802    False
    8803    False
    8804    False
    8805    False
    8806    False
    Length: 8790, dtype: bool>



<h2 style="color: red;">Exploratory Data Analysis (EDA)</h2>


```python
# Select the style of the Grid
sns.set_style("whitegrid")

# Selects the type of pallete you wish to you, change the second number to add more hues
chosen_palette = sns.color_palette("pastel", 2)

# Font Selection and Sizing for visualisation 
plt.rcParams['font.family'] = 'sans-serif' # Use a generic sans-serif
plt.rcParams['axes.titlesize'] = 16       # Title font size
plt.rcParams['axes.labelsize'] = 14       # Axis label font size
plt.rcParams['xtick.labelsize'] = 10      # X-tick label size
plt.rcParams['ytick.labelsize'] = 10      # Y-tick label size
plt.rcParams['legend.fontsize'] = 10      # Legend font size
plt.rcParams['axes.titleweight'] = 16 # Make title bold

#Visualisation Creation

fig, axes = plt.subplots(1, 2, figsize=(15, 6))
fig.suptitle('Content Analysis', fontsize=20, fontweight='bold', y=1.01) # adjest Height and postion of title

# --- First Subplot: Distribution of Content Types ---
ax1 = axes[0]
sns.countplot(
    ax=ax1,         # Specify the axis to plot on
    x='Type',
    data=nf,
    hue='Type',     # Still use hue to get distinct colors per type
    palette=chosen_palette,
    legend=False    # Hide legend as colors match x-axis labels
)
ax1.set_title('Distribution of Content Types')
ax1.set_xlabel('Content Type')
ax1.set_ylabel('Count')
sns.despine(ax=ax1) # Remove top and right spines for a cleaner look


# --- Second Subplot: Distribution of Ratings ---
ax2 = axes[1]
# Get the order of ratings by frequency for a cleaner plot
rating_order = nf['New Rating'].value_counts().index

sns.countplot(
    ax=ax2,         # Specify the axis to plot on
    x='New Rating',
    data=nf,
    order=rating_order, # Plot bars in descending order of count
    hue='Type',         # Color bars based on content type
    palette=chosen_palette # Use the same palette for consistency
)
ax2.set_title('Distribution of Ratings by Content Type')
ax2.set_xlabel('New Rating')
ax2.set_ylabel('Count') 
ax2.tick_params(axis='x', rotation=45) 

# Improve legend
handles, labels = ax2.get_legend_handles_labels()
ax2.legend(handles, labels, title='Content Type', loc='upper right')
sns.despine(ax=ax2) # Remove top and right spines

plt.tight_layout(rect=[0, 0, 1, 0.97])
plt.show()

```


    
![png](output_52_0.png)
    


<h3><u>Genre Analysis</u></h3>


```python
# extract and count genres
def extract_genres(df):
    genre_list = df['Listed In'].str.split(', ', expand=True).stack().str.strip().tolist()
    genre_counts = pd.Series(genre_list).value_counts().sort_values(ascending=False)
    return genre_counts
```


```python
# create df for genre counts
genre_counts_all = extract_genres(nf)
```


```python
genre_counts_all = genre_counts_all.sort_values(ascending=False)

plt.figure(figsize=(10, 6))
sns.barplot(
    x=genre_counts_all.head(20).values,
    y=genre_counts_all.head(20).index,
    hue=genre_counts_all.head(20).index,
    palette=sns.color_palette("pastel", 20),  # Using 20 shades from pastel
    legend=False 
)
plt.title('Top 20 Genres on Netflix', fontweight='bold') 
plt.xlabel('Count')
plt.ylabel('Genre')
sns.despine() 

plt.show()
```


    
![png](output_56_0.png)
    


<h3><u>Country Analysis</u></h3>


```python
# extract and count Countrys
def extract_countries(df):
    country_list = df['Country'].str.split(', ', expand=True).stack().str.strip().tolist()
    country_counts = pd.Series(country_list).value_counts().sort_values(ascending=False)
    return country_counts
```


```python
# create df for country counts
country_counts_all = extract_countries(nf)
```


```python
country_counts_all = country_counts_all.sort_values(ascending=False) #Sort country counts
```


```python
plt.figure(figsize=(12, 8))
sns.barplot(x=country_counts_all.head(20).values, y=country_counts_all.head(20).index,  palette='pastel', hue=country_counts_all.head(20).index, legend=False)
plt.title('Top 20 Countries on Netflix', fontweight='bold')
plt.xlabel('Count')
plt.ylabel('Country')
sns.despine()

plt.show()

```


    
![png](output_61_0.png)
    



```python
# Comparison side by side for visuals

country_counts_all = country_counts_all.sort_values(ascending=False)
genre_counts_all = genre_counts_all.sort_values(ascending=False)

plt.figure(figsize=(20, 8)) 

plt.subplot(1, 2, 1)  
sns.barplot(
    x=country_counts_all.head(20).values,
    y=country_counts_all.head(20).index,
    palette='pastel',
    hue=country_counts_all.head(20).index,
    legend=False
)
plt.title('Top 20 Countries on Netflix', fontweight='bold')
plt.xlabel('Count')
plt.ylabel('Country')
sns.despine()

plt.subplot(1, 2, 2)
sns.barplot(
    x=genre_counts_all.head(20).values,
    y=genre_counts_all.head(20).index,
    palette=sns.color_palette("pastel", 20),
    hue=genre_counts_all.head(20).index,  # Assign the y variable to hue
    legend=False
)
plt.title('Top 20 Genres on Netflix', fontweight='bold')
plt.xlabel('Count')
plt.ylabel('Genre')
sns.despine()

plt.tight_layout()  # Adjust subplot parameters for a tight layout
plt.show()
```


    
![png](output_62_0.png)
    


Review od Country counts, this shows that some lines have multiple country submissions, 
 assumption taken that the first country listed is the primary country filmed


```python
nf.Country.value_counts()
```




    Country
    United States                                             2809
    India                                                      972
    Unknown                                                    829
    United Kingdom                                             418
    Japan                                                      243
                                                              ... 
    Germany, Canada, United States                               1
    Denmark, United Kingdom, South Africa, Sweden, Belgium       1
    Serbia, South Korea, Slovenia                                1
    United Kingdom, Spain, Belgium                               1
    South Africa, United States, Japan                           1
    Name: count, Length: 749, dtype: int64




```python
nf['Country'] = nf['Country'].apply(lambda x: x.split(',')[0])
```


```python
nf.Country.value_counts()
```




    Country
    United States     3202
    India             1008
    Unknown            829
    United Kingdom     627
    Canada             271
                      ... 
    West Germany         1
    Slovenia             1
    Guatemala            1
    Jamaica              1
    Somalia              1
    Name: count, Length: 87, dtype: int64




```python
nf['Listed In'] = nf['Listed In'].apply(lambda x: x.split(',')[0])
```

<h2 style="color: red;">Clustering Approach 1</h2>
<h3><u>Data Processing and Modelling with K-Means (Movies and TV Shows)</u></h3>

Clustering Approach 1
Initial Approach was to cluster Movies / TV Shows to understand patterns and groups over release years and duration of content. The data was split into two data frames movies_data and tv_shows_data with durations being extracted from object columns into numerical float columns for TV Shows.

Due to sensitivity of K Means the features are scaled to enable them to be standardized and converted to a scaled dataframe with both columns being numerical.


<h3 style="color: red;">Movies Data</h3>

<h3><u>Dataset seperation</u></h3>


```python
# Extract numerical duration for movies
movie_durations = nf[nf['Type'] == 'Movie']['Duration'].str.extract('(\d+)').astype(float)
movie_durations.rename(columns={0: 'duration_minutes'}, inplace=True)
nf.loc[nf['Type'] == 'Movie', 'duration_numerical'] = movie_durations['duration_minutes']
```


```python
# Extract numerical duration for TV shows (number of seasons)
tv_show_durations = nf[nf['Type'] == 'TV Show']['Duration'].str.extract('(\d+)').astype(float)
tv_show_durations.rename(columns={0: 'duration_seasons'}, inplace=True)
nf.loc[nf['Type'] == 'TV Show', 'duration_numerical'] = tv_show_durations['duration_seasons']
```

<h3><u>Feature Selection</u></h3>


```python
movies_data = nf[nf['Type'] == 'Movie'].dropna(subset=['duration_numerical', 'Release Year']).copy()
```


```python
# Feature selection
features = ['Release Year', 'duration_numerical']
X = movies_data[features]
```

<h3><u>Data Scaling</u></h3>


```python
# K-Means is sensitive to the scale of features. We need to standardize them.
scaler = StandardScaler()
scaled_features = scaler.fit_transform(X)  # This Calculates the mean and standard deviation, then scale.
scaled_df = pd.DataFrame(scaled_features, columns=features)  # This Converts scaled  to DataFrame
```

<h3><u>Parameter Determination and Validation (Movies)</u></h3>

When review the optimal number of clusters this was validated against a Silhouette Score although the optimum score is two visually with the elbow curve the selection for the cluster was five at the next highest score for both TV Shows and Movies


```python
inertia_values = []  # Initialize an empty list to store the inertia. (can also be called wcss and sse)
silhouette_scores = [] # Initialize an empty list to store the silhouette scores.
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)  # Create a KMeans object with k clusters.
    kmeans.fit(scaled_df)  # Fit the KMeans model to the scaled data.
    inertia_values.append(kmeans.inertia_)  # Stores the inertia value.
    if k > 1:
        silhouette_avg = silhouette_score(scaled_df, kmeans.labels_)
        silhouette_scores.append(silhouette_avg)
```


```python
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))  # 1 row, 2 columns, adjust figsize as needed

# Plot the Elbow Method on the left subplot (ax1)
ax1.plot(range(1, 11), inertia_values, marker='o', linestyle='--')
ax1.set_title('Elbow Method for Optimal K (Movies Only)')
ax1.set_xlabel('Number of Clusters (K)')
ax1.set_ylabel('Within Cluster Sum of Squared Distances (Inertia)')
ax1.set_xticks(range(1, 11))
ax1.grid(True)

# Plot the Silhouette Scores on the right subplot (ax2)
ax2.plot(range(2, 11), silhouette_scores, marker='o', linestyle='--')
ax2.set_title('Silhouette Score for Optimal K (Movies Only)')
ax2.set_xlabel('Number of Clusters (K)')
ax2.set_ylabel('Silhouette Score')
ax2.set_xticks(range(2, 11))
ax2.grid(True)

# Adjust layout to prevent overlapping titles/labels
plt.tight_layout()
plt.show()
```


    
![png](output_82_0.png)
    



```python
# Create the table view 
df = pd.DataFrame({'Cluster Number': range(2, 11), 'Silhouette Score': silhouette_scores})
df = df.T # Transpose the dataframe
print(df.to_markdown(index=True, numalign="left", stralign="left"))
```

    |                  | 0        | 1        | 2        | 3        | 4        | 5        | 6        | 7       | 8        |
    |:-----------------|:---------|:---------|:---------|:---------|:---------|:---------|:---------|:--------|:---------|
    | Cluster Number   | 2        | 3        | 4        | 5        | 6        | 7        | 8        | 9       | 10       |
    | Silhouette Score | 0.571067 | 0.369072 | 0.419445 | 0.437926 | 0.416555 | 0.416882 | 0.364496 | 0.36986 | 0.370503 |
    


```python
# Print a view of siolhette scores beside each K Values
for k, score in zip(range(2, 11), silhouette_scores):
    print(f"Silhouette Score for K={k}: {score:.4f}")
```

    Silhouette Score for K=2: 0.5711
    Silhouette Score for K=3: 0.3691
    Silhouette Score for K=4: 0.4194
    Silhouette Score for K=5: 0.4379
    Silhouette Score for K=6: 0.4166
    Silhouette Score for K=7: 0.4169
    Silhouette Score for K=8: 0.3645
    Silhouette Score for K=9: 0.3699
    Silhouette Score for K=10: 0.3705
    


```python
# Choosen value of K
optimal_k = 5
```

<h3><u>Run K Means Clustering</u></h3>


```python
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
kmeans.fit(scaled_df)  # Fit the model to the scaled data.
labels = kmeans.labels_  # Get the cluster labels for each data point.
movies_data['cluster'] = labels  # Addz the cluster labels as a new column in the DataFrame.
```


```python
# Print the cluster centers for better understanding
centers = scaler.inverse_transform(kmeans.cluster_centers_)
print(f"\nCluster Centers (K={optimal_k}, Movies Only):")
for i, center in enumerate(centers):
    print(f"Cluster {i+1}: Release Year = {center[0]:.2f}, Duration = {center[1]:.2f}")
```

    
    Cluster Centers (K=5, Movies Only):
    Cluster 1: Release Year = 2013.87, Duration = 136.07
    Cluster 2: Release Year = 2016.80, Duration = 54.46
    Cluster 3: Release Year = 1975.40, Duration = 121.20
    Cluster 4: Release Year = 2016.71, Duration = 96.82
    Cluster 5: Release Year = 2000.96, Duration = 102.75
    


```python
plt.figure(figsize=(14, 8), dpi=300)
sns.set_style("whitegrid")

sns.scatterplot(x='Release Year', y='duration_numerical', hue='cluster', data=movies_data,
                palette='viridis', s=120, alpha=0.7, edgecolor='black', linewidth=0.5)

# Add the red dots for the cluster centers
plt.scatter(centers[:, 0], centers[:, 1], c='red', marker='o', s=100, label='Cluster Centers')

plt.title('Clustering of Netflix Movies by Release Year and Duration', fontsize=18)
plt.xlabel('Release Year', fontsize=14)
plt.ylabel('Duration (minutes)', fontsize=14)
plt.legend(title='Movie Cluster', fontsize=12, loc='upper left')
plt.grid(False)
plt.tight_layout()
plt.show()

# Saving as a high-quality PNG
plt.savefig('movie_clusters_high_quality.png', dpi=300, bbox_inches='tight')
```


    
![png](output_89_0.png)
    



    <Figure size 640x480 with 0 Axes>


<h3><u>Analyse the clusters.</u></h3>


```python
print("\nCluster Analysis Review (Example for K=5, Movies Only):")
for i in range(optimal_k):
    print(f"\nCluster {i+1}:")
    cluster_data = movies_data[movies_data['cluster'] == i]  # Get the data points in the cluster.
    print(f"  Number of data points: {len(cluster_data)}")  # Print the number of data points.
    print(f"  Average Release Year: {cluster_data['Release Year'].mean():.2f}")  # Print the average release year.
    print(f"  Average Duration: {cluster_data['duration_numerical'].mean():.2f}")  # Print the average duration.
    # You could add more analysis here.
```

    
    Cluster Analysis Review (Example for K=5, Movies Only):
    
    Cluster 1:
      Number of data points: 1138
      Average Release Year: 2013.86
      Average Duration: 136.10
    
    Cluster 2:
      Number of data points: 867
      Average Release Year: 2016.80
      Average Duration: 54.46
    
    Cluster 3:
      Number of data points: 215
      Average Release Year: 1975.40
      Average Duration: 121.20
    
    Cluster 4:
      Number of data points: 3274
      Average Release Year: 2016.71
      Average Duration: 96.83
    
    Cluster 5:
      Number of data points: 632
      Average Release Year: 2000.96
      Average Duration: 102.66
    

<h3 style="color: red;">TV Show Data</h3>


<h3><u>Feature Selection</u></h3>


```python
tv_shows_data = nf[nf['Type'] == 'TV Show'].copy()
```


```python
# Extract numerical duration (number of seasons)
tv_shows_data['duration_numerical'] = tv_shows_data['Duration'].str.extract('(\d+)').astype(float)
```


```python
# Drop rows where 'duration_numerical' or 'release_year' is NaN
tv_shows_data.dropna(subset=['duration_numerical', 'Release Year'], inplace=True)
```


```python
# Select the numerical features for clustering TV Shows
features_tv = tv_shows_data[['Release Year', 'duration_numerical']].copy()
```


```python
# Data Scaling (same as before, but on the TV Show features)
scaler= StandardScaler()
scaled_features = scaler.fit_transform(features_tv)
scaled_df= pd.DataFrame(scaled_features, columns=features_tv.columns)
```


```python
scaled_df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Release Year</th>
      <th>duration_numerical</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.762519</td>
      <td>0.160045</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.762519</td>
      <td>-0.484978</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.762519</td>
      <td>-0.484978</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.762519</td>
      <td>0.160045</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.762519</td>
      <td>-0.484978</td>
    </tr>
  </tbody>
</table>
</div>



<h3><u>Parameter Determination and Validation (Movies)</u></h3>


```python
inertia_values = []  # Initialize an empty list to store the inertia.
silhouette_scores = [] # Initialize an empty list to store the silhouette scores.
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)  # Create a KMeans object with k clusters.
    kmeans.fit(scaled_df)  # Fit the KMeans model to the scaled data.
    inertia_values.append(kmeans.inertia_)  # Store the inertia value.
    if k > 1:
        silhouette_avg = silhouette_score(scaled_df, kmeans.labels_)
        silhouette_scores.append(silhouette_avg)
```


```python
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Plot the Elbow Method on the left subplot (ax1)
ax1.plot(range(1, 11), inertia_values, marker='o', linestyle='--')
ax1.set_title('Elbow Method for Optimal K (TV Only)')
ax1.set_xlabel('Number of Clusters (K)')
ax1.set_ylabel('Within Cluster Sum of Squared Distances (Inertia)')
ax1.set_xticks(range(1, 11))
ax1.grid(True)

# Plot the Silhouette Scores on the right subplot (ax2)
ax2.plot(range(2, 11), silhouette_scores, marker='o', linestyle='--')
ax2.set_title('Silhouette Score for Optimal K (TV Only)')
ax2.set_xlabel('Number of Clusters (K)')
ax2.set_ylabel('Silhouette Score')
ax2.set_xticks(range(2, 11))
ax2.grid(True)

# Adjust layout to prevent overlapping titles/labels
plt.tight_layout()
plt.show()
```


    
![png](output_102_0.png)
    



```python
df = pd.DataFrame({'Cluster Number': range(2, 11), 'Silhouette Score': silhouette_scores})
df = df.T # Transpose the dataframe
print(df.to_markdown(index=True, numalign="left", stralign="left"))
```

    |                  | 0        | 1        | 2      | 3        | 4        | 5        | 6        | 7        | 8        |
    |:-----------------|:---------|:---------|:-------|:---------|:---------|:---------|:---------|:---------|:---------|
    | Cluster Number   | 2        | 3        | 4      | 5        | 6        | 7        | 8        | 9        | 10       |
    | Silhouette Score | 0.667645 | 0.664916 | 0.5644 | 0.574745 | 0.560572 | 0.514718 | 0.520421 | 0.513812 | 0.501392 |
    


```python
# Print the silhouette scores for each K
for k, score in zip(range(2, 11), silhouette_scores):
    print(f"Silhouette Score for K={k}: {score:.4f}")
```

    Silhouette Score for K=2: 0.6676
    Silhouette Score for K=3: 0.6649
    Silhouette Score for K=4: 0.5644
    Silhouette Score for K=5: 0.5747
    Silhouette Score for K=6: 0.5606
    Silhouette Score for K=7: 0.5147
    Silhouette Score for K=8: 0.5204
    Silhouette Score for K=9: 0.5138
    Silhouette Score for K=10: 0.5014
    


```python
optimal_k = 5  # Replace with the K you choose.
```


```python
# Run K-means clustering with the chosen optimal K.
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
kmeans.fit(scaled_df)  # Fit the model to the scaled data.
labels = kmeans.labels_  # Get the cluster labels for each data point.
tv_shows_data['cluster'] = labels  # Add the cluster labels as a new column in the DataFrame.
```


```python
# Print the cluster center
centers = scaler.inverse_transform(kmeans.cluster_centers_)
print(f"\nCluster Centers (K={optimal_k}, Movies Only):")
for i, center in enumerate(centers):
    print(f"Cluster {i+1}: Release Year = {center[0]:.2f}, Duration = {center[1]:.2f}")
```

    
    Cluster Centers (K=5, Movies Only):
    Cluster 1: Release Year = 2008.72, Duration = 1.28
    Cluster 2: Release Year = 2018.26, Duration = 1.20
    Cluster 3: Release Year = 2018.07, Duration = 3.77
    Cluster 4: Release Year = 1976.38, Duration = 2.86
    Cluster 5: Release Year = 2012.81, Duration = 8.31
    


```python
plt.figure(figsize=(14, 8), dpi=300)
sns.set_style("whitegrid")

sns.scatterplot(x='Release Year', y='duration_numerical', hue='cluster', data=tv_shows_data,
                palette='viridis', s=120, alpha=0.7, edgecolor='black', linewidth=0.5)

# Add the red dots for the cluster centers
plt.scatter(centers[:, 0], centers[:, 1], c='red', marker='o', s=100, label='Cluster Centers')

plt.title('Clustering of Netflix TV Shows by Release Year and Duration', fontsize=18)
plt.xlabel('Release Year', fontsize=14)
plt.ylabel('Duration (minutes)', fontsize=14)
plt.legend(title='Movie Cluster', fontsize=12, loc='upper left')
plt.grid(False)
plt.tight_layout()
plt.show()

# Saving as a high-quality PNG
plt.savefig('TV Shows_clusters_high_quality.png', dpi=300, bbox_inches='tight')
```


    
![png](output_108_0.png)
    



    <Figure size 640x480 with 0 Axes>


<h2 style="color: red;">Clustering Approach 2</h2>

Secondary approach to understand insight between Genre and Country, this data required cleaning, initial assumption taken, due to some data having multiple countries and multiple Genres

To extract only the first Country and First Genre under the assumption this is the Primary datapoint, then conversion from Categorical to numerical datapoints
Using a MultiLabelBinarizer to create separate Binary data frames for Country and Genre allocation

<h3><u>Data Preperation for Analysis</u></h3>


```python
# maximum number of clusters
MAX_K = 15
# Number of top items for visualisations
TOP_N_VIZ = 5
# Number of top countries for gap analysis
N_TOP_COUNTRIES = 10
# Number of top genres (gaps/focus) to show in comparison plot
N_GAPS_TO_SHOW = 10
# Number of top global genres to analyaia in visualsiations
N_TOP_GLOBAL_GENRES = 10 
```


```python
nf_subset = nf[['Listed In', 'Country']].copy()
```


```python
nf_subset.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Listed In</th>
      <th>Country</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Documentaries</td>
      <td>United States</td>
    </tr>
    <tr>
      <th>1</th>
      <td>International TV Shows</td>
      <td>South Africa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Crime TV Shows</td>
      <td>Unknown</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Docuseries</td>
      <td>Unknown</td>
    </tr>
    <tr>
      <th>4</th>
      <td>International TV Shows</td>
      <td>India</td>
    </tr>
  </tbody>
</table>
</div>



<h3><u>Feature Selection</u></h3>


```python
# Split strings into lists
genre_item_lists = nf_subset['Listed In'].apply(lambda x: [item.strip() for item in x.split(',')])
```


```python
# Initialize and fit the binarizer for genres, this creates individual columns for each genre and later country to show a 1 or 0
genre_mlb = MultiLabelBinarizer()
genre_binarized_features = genre_mlb.fit_transform(genre_item_lists)
```


```python
# df created for new binary columns
genre_df = pd.DataFrame(genre_binarized_features, columns=genre_mlb.classes_, index=nf_subset.index)
genre_df.head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Action &amp; Adventure</th>
      <th>Anime Features</th>
      <th>Anime Series</th>
      <th>British TV Shows</th>
      <th>Children &amp; Family Movies</th>
      <th>Classic &amp; Cult TV</th>
      <th>Classic Movies</th>
      <th>Comedies</th>
      <th>Crime TV Shows</th>
      <th>Cult Movies</th>
      <th>...</th>
      <th>Sports Movies</th>
      <th>Stand-Up Comedy</th>
      <th>Stand-Up Comedy &amp; Talk Shows</th>
      <th>TV Action &amp; Adventure</th>
      <th>TV Comedies</th>
      <th>TV Dramas</th>
      <th>TV Horror</th>
      <th>TV Sci-Fi &amp; Fantasy</th>
      <th>TV Shows</th>
      <th>Thrillers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 36 columns</p>
</div>




```python
country_item_lists = nf_subset['Country'].apply(lambda x: [item.strip() for item in x.split(',')])
```


```python
country_mlb = MultiLabelBinarizer()
country_binarized_features = country_mlb.fit_transform(country_item_lists)
```


```python
country_df = pd.DataFrame(country_binarized_features, columns=country_mlb.classes_, index=nf_subset.index)
country_df.head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Argentina</th>
      <th>Australia</th>
      <th>Austria</th>
      <th>Bangladesh</th>
      <th>Belarus</th>
      <th>Belgium</th>
      <th>Brazil</th>
      <th>Bulgaria</th>
      <th>Cambodia</th>
      <th>...</th>
      <th>Ukraine</th>
      <th>United Arab Emirates</th>
      <th>United Kingdom</th>
      <th>United States</th>
      <th>Unknown</th>
      <th>Uruguay</th>
      <th>Venezuela</th>
      <th>Vietnam</th>
      <th>West Germany</th>
      <th>Zimbabwe</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 87 columns</p>
</div>




<h3><u>Combining Features</u></h3>


```python
cluster_features = pd.concat([genre_df, country_df], axis=1)
```


```python
cluster_features.shape
```




    (8790, 123)



<h3><u>Parameter Determination and Validation (Movies)</u></h3>

When reviewing Parameter Determination for K it was evident that silhouette score needed additional validation and extension from 10 clusters to 15 to decide K from elbow, this was further validated against Calinski-Harabasz Index and Davies-Bouldin Index to determine Optimal K, which gave mixed output on strength of clusters, decision was taken to use 7 based on elbow and Silhouette.


```python
sse = [] # Sum of Squared Errors 
k_range = range(1, MAX_K + 1)
silhouette_scores = []
calinski_harabasz_scores = []
davies_bouldin_scores = []
```


```python
for k in k_range:
    # Use n_init='auto' or 10 for newer scikit-learn versions
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10, verbose=0)
    kmeans.fit(cluster_features)
    sse.append(kmeans.inertia_)
    print(f"Calculated SSE for K={k}")
    if k > 1:
        silhouette_avg = silhouette_score(cluster_features, kmeans.labels_)
        silhouette_scores.append(silhouette_avg)
        calinski_harabasz = calinski_harabasz_score(cluster_features, kmeans.labels_)
        davies_bouldin = davies_bouldin_score(cluster_features, kmeans.labels_)
        calinski_harabasz_scores.append(calinski_harabasz)
        davies_bouldin_scores.append(davies_bouldin)
    else:
        silhouette_scores.append(0)
        calinski_harabasz_scores.append(0)
        davies_bouldin_scores.append(0)
```

    Calculated SSE for K=1
    Calculated SSE for K=2
    Calculated SSE for K=3
    Calculated SSE for K=4
    Calculated SSE for K=5
    Calculated SSE for K=6
    Calculated SSE for K=7
    Calculated SSE for K=8
    Calculated SSE for K=9
    Calculated SSE for K=10
    Calculated SSE for K=11
    Calculated SSE for K=12
    Calculated SSE for K=13
    Calculated SSE for K=14
    Calculated SSE for K=15
    


```python
fig, axs = plt.subplots(2, 2, figsize=(16, 12))
axs = axs.flatten()

# Plot the Elbow Method top left
axs[0].plot(range(1, MAX_K + 1), sse, marker='o', linestyle='--')
axs[0].set_title('Elbow Method for Optimal K (Genres and Countries)')
axs[0].set_xlabel('Number of Clusters (K)')
axs[0].set_ylabel('Within Cluster Sum of Squared Distances (Inertia)')
axs[0].set_xticks(range(1, MAX_K + 1))
axs[0].grid(True)

# Plot the Silhouette Scores top right
axs[1].plot(range(1, MAX_K + 1), silhouette_scores, marker='o', linestyle='--')
axs[1].set_title('Silhouette Score for Optimal K')
axs[1].set_xlabel('Number of Clusters (K)')
axs[1].set_ylabel('Silhouette Score')
axs[1].set_xticks(range(1, MAX_K + 1))
axs[1].grid(True)

# Plot Calinski Harabasz Score bottom left
axs[2].plot(range(2, MAX_K + 1), calinski_harabasz_scores[1:], marker='o', linestyle='--')
axs[2].set_title('Calinski-Harabasz Index')
axs[2].set_xlabel('Number of Clusters (K)')
axs[2].set_ylabel('Calinski-Harabasz Index')
axs[2].set_xticks(range(2, MAX_K + 1))
axs[2].grid(True)

# Plot Davies Bouldin Score bottom right
axs[3].plot(range(2, MAX_K + 1), davies_bouldin_scores[1:], marker='o', linestyle='--')
axs[3].set_title('Davies-Bouldin Index')
axs[3].set_xlabel('Number of Clusters (K)')
axs[3].set_ylabel('Davies-Bouldin Index')
axs[3].set_xticks(range(2, MAX_K + 1))
axs[3].grid(True)
```


    
![png](output_129_0.png)
    



```python
chosen_k = 7
```


```python
final_kmeans = KMeans(n_clusters=chosen_k, random_state=42, n_init=10)
cluster_labels = final_kmeans.fit_predict(cluster_features)
```


```python
nf_subset['Cluster'] = cluster_labels
```

<h3><u>Cluster Analysis</u></h3>


```python
print("\nCluster Sizes:")
print(nf_subset['Cluster'].value_counts().sort_index())
```

    
    Cluster Sizes:
    Cluster
    0    1861
    1    2056
    2     432
    3    1210
    4     773
    5    1599
    6     859
    Name: count, dtype: int64
    

<h3><u>Top Genres/Countries per Cluster</u></h3>

The clustering results looked at top 5 countries by cluster, this did not give a clear output to highlight potential opportunities by genre for specific countries, PCA and visualisation on scatter plot also used 


```python
# Get original column names back from the binarizers
genre_names = list(genre_mlb.classes_)
country_names = list(country_mlb.classes_)
```


```python
# Combine the cluster labels with the binarized features for analysis
analysis_df = pd.concat([cluster_features, nf_subset['Cluster']], axis=1)
```


```python
# Define base sequential colormaps for clusters
base_cmaps = ['Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys', 'YlOrBr', 'BuGn', 'YlGn', 'PuRd']

plots_per_figure = 8
num_figures = (chosen_k + plots_per_figure - 1) // plots_per_figure

for fig_num in range(num_figures):
    # Create a 4x4 subplot figure
    fig, axes = plt.subplots(4, 4, figsize=(14, 12), squeeze=False) # 4x4 grid
    axes_flat = axes.flatten() # Flatten for easier indexing
    plot_idx = 0 # Reset plot index for each figure

    # Determine the range of cluster indices for this figure
    start_cluster_idx = fig_num * plots_per_figure
    end_cluster_idx = min(start_cluster_idx + plots_per_figure, chosen_k)

    # Loop through the clusters for the current figure
    for i in range(start_cluster_idx, end_cluster_idx):
        if plot_idx >= len(axes_flat): # Should not happen with correct logic, but safety check
            break

        cluster_data = analysis_df[analysis_df['Cluster'] == i]
        term_counts = cluster_data[genre_names + country_names].sum()
        genre_counts = term_counts[genre_names].sort_values(ascending=False)
        country_counts = term_counts[country_names].sort_values(ascending=False)

        # Visualization for Cluster i
        # Select colormap for this cluster
        cmap_name = base_cmaps[i % len(base_cmaps)]
        cmap = cm.get_cmap(cmap_name)

        # Genre Plot
        ax_genre = axes_flat[plot_idx]
        top_genres = genre_counts.head(TOP_N_VIZ)
        top_genres = top_genres[top_genres > 0]
        if not top_genres.empty:
            single_genre_color = cmap(0.7) # Pick a prominent shade
            top_genres.sort_values().plot(kind='barh', ax=ax_genre, color=single_genre_color)
            ax_genre.set_title(f'Cluster {i}: Top {TOP_N_VIZ} Genres', fontsize=9) # Adjusted font size
            ax_genre.set_xlabel('Count', fontsize=7)
            ax_genre.tick_params(axis='both', which='major', labelsize=7)
            ax_genre.grid(axis='x', linestyle='--', alpha=0.6)
        else:
            ax_genre.set_title(f'Cluster {i}: No Genres > 0 Count', fontsize=9)
            ax_genre.set_xticks([])
            ax_genre.set_yticks([])
        plot_idx += 1 # Move to next subplot index

        # Country Plot
        if plot_idx >= len(axes_flat): break # Check again before country plot
        ax_country = axes_flat[plot_idx]
        top_countries = country_counts.head(TOP_N_VIZ)
        top_countries = top_countries[top_countries > 0]
        if not top_countries.empty:
            num_bars = len(top_countries)
            # Generate shades from the *same* colormap used for genres
            country_bar_colors = [cmap(j / num_bars * 0.6 + 0.2) for j in range(num_bars)] # Use shades from 0.2 to 0.8
            top_countries.sort_values().plot(kind='barh', ax=ax_country, color=country_bar_colors)
            ax_country.set_title(f'Cluster {i}: Top {TOP_N_VIZ} Countries', fontsize=9) # Adjusted font size
            ax_country.set_xlabel('Count', fontsize=7)
            ax_country.tick_params(axis='both', which='major', labelsize=7)
            ax_country.grid(axis='x', linestyle='--', alpha=0.6)
        else:
            ax_country.set_title(f'Cluster {i}: No Countries > 0 Count', fontsize=9)
            ax_country.set_xticks([])
            ax_country.set_yticks([])
        plot_idx += 1 # Move to next subplot index

    # Hide any remaining unused subplots on the current figure
    while plot_idx < len(axes_flat):
        axes_flat[plot_idx].set_visible(False)
        plot_idx += 1

    # Adjust layout and show the figure
    plt.tight_layout(pad=1.0) # Adjust padding
    plt.show()
```

    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    C:\Users\SISSONL\AppData\Local\Temp\ipykernel_25640\2429885849.py:30: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
      cmap = cm.get_cmap(cmap_name)
    


    
![png](output_139_1.png)
    


## Visualize Movie Clusters using PCA (Scatter Plot)


```python
# Reduce dimensions using PCA
n_components = 2
pca = PCA(n_components=n_components)
pca_features = pca.fit_transform(cluster_features) # Use the combined movie genre/country features

print(f"Reduced movie features to {n_components} dimensions using PCA.")
```

    Reduced movie features to 2 dimensions using PCA.
    


```python
# Create a DataFrame with PCA results and cluster labels
pca_df = pd.DataFrame(
    data=pca_features,
    columns=[f'PCA Component {i+1}' for i in range(n_components)],
    index=cluster_features.index
)
pca_df['Cluster'] = nf_subset['Cluster'] 
```


```python
# Create the scatter plot
plt.figure(figsize=(12, 8))
sns.scatterplot(
    x='PCA Component 1',
    y='PCA Component 2',
    hue='Cluster',
    palette=sns.color_palette("hsv", chosen_k), # Using hsv for scatter distinctness
    data=pca_df,
    legend='full',
    alpha=0.7
)

plt.title(f'Netflix Movie Clusters (K={chosen_k}) visualized with PCA')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.show()
```


    
![png](output_143_0.png)
    


<h2 style="color: red;">Approach 3 - Movie Genre Gap Analysis by Country</h2>

To review Top 10 Country Genres listed against global average to identify opportunities by country to increase genre penetration onto platform


```python
# Identify Top N Countries (Based on Movie Counts)
movies_data['Country'] = movies_data['Country'].fillna('Unknown')
country_lists_movies = movies_data['Country'].apply(lambda x: [c.strip() for c in x.split(',')])
all_countries_movies = country_lists_movies.explode()
top_countries_list = all_countries_movies[all_countries_movies != 'Unknown'].value_counts().head(N_TOP_COUNTRIES).index.tolist()
print(f"Top {N_TOP_COUNTRIES} countries (for movies) found: {top_countries_list}")
```

    Top 10 countries (for movies) found: ['United States', 'India', 'United Kingdom', 'Canada', 'France', 'Spain', 'Egypt', 'Nigeria', 'Mexico', 'Japan']
    


```python
movies_data['Listed In'] = movies_data['Listed In'].fillna('Unknown')
full_genre_item_lists_movies = movies_data['Listed In'].apply(lambda x: [item.strip() for item in x.split(',')])

```


```python
# Use the *same* fitted binarizer (genre_mlb, fitted on movie genres
full_genre_binarized_features_movies = genre_mlb.transform(full_genre_item_lists_movies)
```


```python
# Create DataFrame with genre flags for the movie dataset
full_genre_df_movies = pd.DataFrame(full_genre_binarized_features_movies, columns=genre_mlb.classes_, index=movies_data.index)
```


```python
# --- Calculate Global Movie Genre Proportions (once) ---
global_movie_genre_proportions = full_genre_df_movies.sum() / len(movies_data)
```


```python
country_genre_proportions_dict = {}
```


```python
plots_per_figure = 4
num_figures = (N_TOP_COUNTRIES + plots_per_figure - 1) // plots_per_figure

for fig_num in range(num_figures):
    # Create a 2x2 subplot figure
    fig, axes = plt.subplots(2, 2, figsize=(16, 10)) # Adjusted figsize for 2x2
    axes_flat = axes.flatten() # Flatten for easier indexing
    plot_idx = 0 # Reset plot index for each figure

    # Determine the range of country indices for this figure
    start_country_idx = fig_num * plots_per_figure
    end_country_idx = min(start_country_idx + plots_per_figure, N_TOP_COUNTRIES)

    # Loop through the countries for the current figure
    for country_list_index in range(start_country_idx, end_country_idx):
        if plot_idx >= len(axes_flat): break # Safety check

        target_country = top_countries_list[country_list_index]

        # Calculate Target Country Movie Genre Proportions
        country_filter = movies_data['Country'].str.contains(target_country, na=False, regex=False)
        nf_target_movies = movies_data[country_filter]

        if nf_target_movies.empty:
            #print(f"  Warning: No movies found for country '{target_country}'. Skipping plot.")
            country_genre_proportions_dict[target_country] = pd.Series(dtype=float) # Store empty series
            if plot_idx < len(axes_flat):
                axes_flat[plot_idx].set_visible(False)
            plot_idx += 1
            continue

        target_genre_df_movies = full_genre_df_movies.loc[nf_target_movies.index]
        target_country_movie_genre_proportions = target_genre_df_movies.sum() / len(nf_target_movies)

        country_genre_proportions_dict[target_country] = target_country_movie_genre_proportions

        # Create Comparison DataFrame
        country_col = f'{target_country} Proportion' # Define country column name
        global_col = 'Global Movie Proportion'
        genre_comparison_df = pd.DataFrame({
            global_col: global_movie_genre_proportions,
            country_col: target_country_movie_genre_proportions
        })
        genre_comparison_df['Difference'] = genre_comparison_df[country_col] - genre_comparison_df[global_col]
        genre_comparison_df = genre_comparison_df.sort_values('Difference') # Sort by difference to find gaps/focus

        # Visualize the Comparison 
        top_gaps = genre_comparison_df.head(N_GAPS_TO_SHOW)
        top_focus = genre_comparison_df.tail(N_GAPS_TO_SHOW)
        plot_df = pd.concat([top_gaps, top_focus])

        # Sort the combined plot_df by Country Proportion descending for plotting
        plot_df = plot_df.sort_values(country_col, ascending=False)

        ax = axes_flat[plot_idx]

        # Plot Country Proportion as Bars
        bar_color = 'skyblue'
        line_color = 'orangered'

        plot_df[country_col].plot(
            kind='bar',
            ax=ax,
            rot=90,
            fontsize=7,
            color=bar_color,
            label=country_col
        )

        # Plot Global Proportion as Line on the same axis
        x_coords = np.arange(len(plot_df.index))
        ax.plot(
            x_coords,
            plot_df[global_col],
            color=line_color,
            marker='o',
            linestyle='-',
            linewidth=2,
            markersize=4,
            label=global_col
        )

        # Set x-ticks and labels correctly after plotting both
        ax.set_xticks(x_coords)
        ax.set_xticklabels(plot_df.index, rotation=90, ha='center')

        ax.set_title(f'{target_country} vs. Global (Sorted by Country Prop.)', fontsize=10)
        ax.set_ylabel('Proportion', fontsize=8)
        ax.set_xlabel('Movie Genre', fontsize=8)
        ax.legend(title='Region', fontsize=7)
        ax.tick_params(axis='x', labelsize=7)
        ax.tick_params(axis='y', labelsize=7)

        # Remove grid lines
        ax.grid(False)

        # Remove top and right spines
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)

        plot_idx += 1 # Move to next subplot index

    # Hide any remaining unused subplots on the current figure
    while plot_idx < len(axes_flat):
        axes_flat[plot_idx].set_visible(False)
        plot_idx += 1

    # Adjust layout and show the figure
    plt.tight_layout(pad=1.5)
    plt.show()
```


    
![png](output_152_0.png)
    



    
![png](output_152_1.png)
    



    
![png](output_152_2.png)
    


Early investigation showed potential insights for example United Kingdom highlights gaps within comedies and Family movies but strength in Documentaries as well as other areas for growth

<h3><u>Review by Genre Top Countries vs proportion against global average</u></h3>


```python
# Identify top N global genres
top_global_genres = global_movie_genre_proportions.sort_values(ascending=False).head(N_TOP_GLOBAL_GENRES).index.tolist()
print(f"Top {N_TOP_GLOBAL_GENRES} Global Movie Genres: {top_global_genres}")
```

    Top 10 Global Movie Genres: ['Dramas', 'Comedies', 'Action & Adventure', 'Documentaries', 'Children & Family Movies', 'Stand-Up Comedy', 'Horror Movies', 'International Movies', 'Classic Movies', 'Thrillers']
    


```python
# Prepare data for plotting: Genre as index, Countries as columns
genre_focus_df = pd.DataFrame(index=top_global_genres)
for country, proportions in country_genre_proportions_dict.items():
    # Ensure the proportions series is not empty and contains the genres
    if not proportions.empty:
        genre_focus_df[country] = proportions.reindex(top_global_genres).fillna(0) # Reindex to match top genres and fill NaNs
    else:
        genre_focus_df[country] = 0.0 # Assign zero if country had no movies
```


```python
genres_per_figure = 9 
num_genre_figures = (N_TOP_GLOBAL_GENRES + genres_per_figure - 1) // genres_per_figure

# Define colors for bars above/below average
color_above = 'mediumseagreen'
color_below = 'sandybrown'

for fig_num in range(num_genre_figures):

    fig, axes = plt.subplots(3, 3, figsize=(12, 9))
    axes_flat = axes.flatten()
    plot_idx = 0

   
    start_genre_idx = fig_num * genres_per_figure
    end_genre_idx = min(start_genre_idx + genres_per_figure, N_TOP_GLOBAL_GENRES)

    # Loop through the top global genres
    for genre_idx in range(start_genre_idx, end_genre_idx):
        if plot_idx >= len(axes_flat): break

        target_genre = top_global_genres[genre_idx]

        # proportions for genre across all top countries
        country_proportions_for_genre = genre_focus_df.loc[target_genre].sort_values(ascending=False)

        # global average for this specific genre
        global_avg_for_genre = global_movie_genre_proportions.get(target_genre, 0)

        bar_colors = []
        for country in country_proportions_for_genre.index:
            if country_proportions_for_genre[country] >= global_avg_for_genre:
                bar_colors.append(color_above)
            else:
                bar_colors.append(color_below)


     
        ax = axes_flat[plot_idx]
        country_proportions_for_genre.plot(
            kind='bar',
            ax=ax,
            rot=90, 
            fontsize=8,
            color=bar_colors 
        )
        ax.set_title(f'"{target_genre}" Proportion in Top Countries', fontsize=10)
        ax.set_ylabel('Proportion within Country', fontsize=8)
        ax.set_xlabel('Country', fontsize=8)
        ax.tick_params(axis='y', labelsize=8)
        # Set x-axis labels to be vertical
        ax.tick_params(axis='x', rotation=90, labelsize=8)

        # Format y-axis as percentage
        ax.yaxis.set_major_formatter(mticker.PercentFormatter(xmax=1.0))

        # add in an global average line
        global_line = ax.axhline(
            global_avg_for_genre,
            color='red',
            linestyle='--',
            linewidth=1.5,
            label=f'Global Avg ({global_avg_for_genre:.2%})'
        )
    
        # Remove grid lines
        ax.grid(False)

        # Only show legend for the global average line
        ax.legend(handles=[global_line], fontsize=7)

        # Remove top and right spines
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)

        plot_idx += 1

    # Hide any remaining unused subplots on the current figure
    while plot_idx < len(axes_flat):
        axes_flat[plot_idx].set_visible(False)
        plot_idx += 1

    # Adjust layout and show the figure
    plt.tight_layout(pad=1.5)
    plt.show()
```


    
![png](output_157_0.png)
    



    
![png](output_157_1.png)
    


<h2 style="color: red;">Conclusion</h2>
The analysis successfully identified trends, movie release density and duration over decades. The genre gap analysis approach supported potential insights, highlighting specific areas, like the UK market, where genre offerings diverge significantly from global averages, large opportunities in specific genres Horror and Stand-up comedy this suggests further strategic opportunities.
Although methodology used provided a flexible framework for exploration, the analysis had limitations due to assumptions made during data pre-processing, particularly regarding primary country and genre allocation. Not allowing for multi genre films or the introduction of sub genres and multiple listing across global countries.
In summary, the project successfully identified key content trends and potential market gaps, as a starting block to investigate paving more robust strategic analysis through the proposed next steps 

<h3 style="color: red;">Next Steps</h3>
Based on the results of the three approaches taken, the next steps would be.

- Remove the assumption from Country column, to review impact on Genre performance 
- Use of secondary data set from IMBD or rotten tomatoes to understand popularity of Score of Movie / TV Show and its impact on results against Country (Lakshmi, N. 2016) and (Leone, S. 2020).
- Finally, look at country subscriber numbers , against all above criteria to delve into more strategic results to drive revenue growth with further exploration of gap analysis. (sureshmuthusamy001p. 2023), (adnananam. 2023) and (mauryansshivam. 2023).





<h3 style="color: black;">References</h3>

1: Shivamb. (2025). Netflix Movies and TV Shows. [online] Available at: https://www.kaggle.com/datasets/shivamb/netflix-shows [Accessed 2 May 2025].

2: AInvest (2025). Netflix's Content Strategy: A Global Powerhouse in 2025. [online] AInvest. Available at: https://www.ainvest.com/news/netflix-content-strategy-global-powerhouse-2025-2503/ [Accessed 4 May 2025].

3: Oakes, O. (2025). Live programming drives growth at Netflix as attention shifts to adtech. [online] The Media Leader. Available at: https://uk.themedialeader.com/live-programming-drives-growth-at-netflix-as-attention-shifts-to-adtech/ [Accessed 4 May 2025]

4: Works, A. (2024). All About Netflix Artificial Intelligence: The Truth Behind Personalized Content. [online] Litslink Blog. Available at: https://litslink.com/blog/all-about-netflix-artificial-intelligence-the-truth-behind-personalized-content/ [Accessed 4 May 2025].

5: Livemint (2025). OpenAI tech powers Netflix's new mood-based search feature: All you need to know. [online] Mint. Available at: https://www.livemint.com/technology/tech-news/openai-tech-powers-netflix-s-new-mood-based-search-feature-all-you-need-to-know-11744738594106.html [Accessed 4 May 2025].

6: Lakshmi, N. (2016). IMDB Dataset of 50K Movie Reviews. [Data set]. Kaggle. Available at: https://www.kaggle.com/datasets/lakshmi25npathi/imdb-dataset-of-50k-movie-reviews [Accessed 4 May 2025]

7: Leone, S. (2020). Rotten Tomatoes Movies and Critic Reviews Dataset. [Data set]. Kaggle. Available at: https://www.kaggle.com/datasets/stefanoleone992/rotten-tomatoes-movies-and-critic-reviews-dataset [Accessed 4 May 2025].
8: sureshmuthusamy001p. (2023). Netflix Customer Subscription. [Data set]. Kaggle. Available at: https://www.kaggle.com/datasets/sureshmuthusamy001p/netflix-customer-subscription [Accessed 4 May 2025].

9: adnananam. (2023). Netflix Revenue and Usage Statistics. [Data set]. Kaggle. Available at: https://www.kaggle.com/datasets/adnananam/netflix-revenue-and-usage-statistics [Accessed 4 May 2025]
10: mauryansshivam. (2023). Netflix OTT Revenue and Subscribers. [Data set]. Kaggle. Available at: https://www.kaggle.com/datasets/mauryansshivam/netflix-ott-revenue-and-subscribers [Accessed 4 May 2025].



